package com.example.financemanager.entities;

import jakarta.persistence.*;
import org.hibernate.annotations.CreationTimestamp;

import java.time.LocalDate;
import java.time.LocalDateTime;

/**
 * Entity representing a financial transaction in the Finance Manager system.
 *
 * <p>Supports three types of transactions:</p>
 * <ol>
 *   <li><b>Regular transactions</b>: One-time income or expense with no due date</li>
 *   <li><b>Recurring bills</b>: Monthly recurring transactions on a specific day (e.g., rent on the 1st)</li>
 *   <li><b>Scheduled transactions</b>: One-time transactions with a specific due date</li>
 * </ol>
 *
 * <p>Recurring bills automatically calculate the next due date and handle month-end edge cases
 * (e.g., if a bill is due on day 31, it will be adjusted to the last day of months with fewer days).</p>
 *
 * <h3>Relationships:</h3>
 * <ul>
 *   <li>Many-to-One with User: Multiple transactions belong to one user</li>
 * </ul>
 *
 * <h3>Transaction Types:</h3>
 * <ul>
 *   <li><b>INCOME</b>: Money received (salary, freelance work, etc.)</li>
 *   <li><b>EXPENSE</b>: Money spent (rent, food, utilities, etc.)</li>
 * </ul>
 *
 * @author Finance Manager Team
 * @version 1.0
 * @since 2025-01-28
 * @see User
 */
@Entity
@Table(name = "transactions")
public class Transaction {

    /**
     * Unique identifier for the transaction.
     * Auto-generated by the database.
     */
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    /**
     * The user who owns this transaction.
     * Required field - every transaction must belong to a user.
     * Deletion of user will cascade to delete associated transactions.
     */
    @ManyToOne
    @JoinColumn(name = "user_id", nullable = false)
    private User user;

    /**
     * Description of the transaction.
     * Examples: "Monthly Rent", "Grocery Shopping", "Freelance Payment"
     */
    private String description;

    /**
     * Amount of the transaction in the currency used by the system.
     * Always positive - the type field determines if it's income or expense.
     */
    private double amount;

    /**
     * Type of transaction.
     * Valid values: "INCOME" or "EXPENSE"
     */
    private String type;

    /**
     * Category of the transaction.
     * Examples: "Salary", "Rent", "Food", "Utilities", "Healthcare", "Freelance"
     */
    private String category;

    /**
     * Due date for one-time scheduled transactions.
     * Only populated for non-recurring transactions that have a specific due date.
     * Null for regular transactions and recurring bills.
     */
    private LocalDate dueDate;

    /**
     * Indicates whether this is a recurring monthly bill.
     * If true, the transaction repeats every month on the specified dayOfMonth.
     */
    private boolean isRecurring;

    /**
     * Day of month (1-31) when a recurring bill is due.
     * Only applicable when isRecurring is true.
     * Values greater than the number of days in a month are adjusted automatically
     * (e.g., day 31 in February becomes day 28 or 29).
     */
    private Integer dayOfMonth;

    /**
     * Next occurrence date for recurring bills.
     * Automatically calculated and updated when the bill is marked as paid.
     * Handles month-end edge cases correctly.
     */
    private LocalDate nextDueDate;

    /**
     * Payment status for bills (both recurring and one-time with due dates).
     * True if the bill has been paid, false otherwise.
     */
    private boolean isPaid;

    /**
     * Timestamp when the transaction was created.
     * Automatically set by Hibernate on entity creation.
     */
    @CreationTimestamp
    private LocalDateTime createdDate;

    /**
     * Default constructor required by JPA.
     */
    public Transaction() {}

    /**
     * Constructs a recurring bill that repeats monthly on a specific day.
     * The next due date is automatically calculated.
     *
     * @param user the user who owns this transaction
     * @param description brief description of the bill (e.g., "Electric Bill")
     * @param amount the bill amount (must be positive)
     * @param type transaction type ("INCOME" or "EXPENSE", typically "EXPENSE" for bills)
     * @param category transaction category (e.g., "Utilities", "Rent")
     * @param dayOfMonth day of month when bill is due (1-31, adjusted for short months)
     */
    public Transaction(User user, String description, double amount,
                       String type, String category, int dayOfMonth) {
        this.user = user;
        this.description = description;
        this.amount = amount;
        this.type = type;
        this.category = category;
        this.isRecurring = true;
        this.dayOfMonth = dayOfMonth;
        this.isPaid = false;
        this.nextDueDate = calculateNextDueDate(dayOfMonth);
    }

    /**
     * Constructs a regular one-time transaction with no due date.
     * Used for tracking past income or expenses.
     *
     * @param user the user who owns this transaction
     * @param description brief description of the transaction
     * @param amount the transaction amount (must be positive)
     * @param type transaction type ("INCOME" or "EXPENSE")
     * @param category transaction category
     */
    public Transaction(User user, String description, double amount,
                       String type, String category) {
        this.user = user;
        this.description = description;
        this.amount = amount;
        this.type = type;
        this.category = category;
        this.isRecurring = false;
    }

    /**
     * Constructs a one-time transaction with a specific due date.
     * Used for scheduled payments or expected income on a specific date.
     *
     * @param user the user who owns this transaction
     * @param description brief description of the transaction
     * @param amount the transaction amount (must be positive)
     * @param type transaction type ("INCOME" or "EXPENSE")
     * @param category transaction category
     * @param dueDate the specific date when this transaction is due
     */
    public Transaction(User user, String description, double amount,
                       String type, String category, LocalDate dueDate) {
        this.user = user;
        this.description = description;
        this.amount = amount;
        this.type = type;
        this.category = category;
        this.dueDate = dueDate;
        this.isRecurring = false;
        this.isPaid = false;
    }

    /**
     * Calculates the next due date for a recurring bill based on the day of month.
     * Handles edge cases where the specified day doesn't exist in certain months.
     *
     * <p><b>Algorithm:</b></p>
     * <ol>
     *   <li>Attempt to create a date in the current month with the specified day</li>
     *   <li>If the current month has fewer days (e.g., day 31 in February),
     *       use the last day of the current month instead</li>
     *   <li>If the calculated date is today or in the past, move to next month</li>
     *   <li>When moving to next month, re-check if that month has the specified day
     *       and adjust if necessary</li>
     * </ol>
     *
     * <p><b>Examples:</b></p>
     * <ul>
     *   <li>If today is Jan 15 and dayOfMonth is 20: Returns Jan 20 (same month)</li>
     *   <li>If today is Jan 25 and dayOfMonth is 20: Returns Feb 20 (next month)</li>
     *   <li>If today is Jan 15 and dayOfMonth is 31: Returns Jan 31 (same month)</li>
     *   <li>If today is Jan 31 and dayOfMonth is 31: Returns Feb 28/29 (adjusted for shorter month)</li>
     *   <li>If today is Feb 15 and dayOfMonth is 31: Returns Feb 28/29 (adjusted)</li>
     * </ul>
     *
     * @param dayOfMonth the desired day of month (1-31)
     * @return the calculated next due date, adjusted for month length if necessary
     */
    private LocalDate calculateNextDueDate(int dayOfMonth) {
        LocalDate today = LocalDate.now();

        // Step 1: Get the number of days in the current month
        int lastDayOfMonth = today.lengthOfMonth();

        // Step 2: Adjust day if it exceeds the month's length
        // Example: If dayOfMonth is 31 but current month only has 28 days, use 28
        int actualDay = Math.min(dayOfMonth, lastDayOfMonth);

        // Step 3: Create a date in the current month with the adjusted day
        LocalDate nextDue = LocalDate.of(today.getYear(), today.getMonth(), actualDay);

        // Step 4: If the calculated date is today or in the past, move to next month
        if (nextDue.isBefore(today) || nextDue.isEqual(today)) {
            // Move to the same day next month (temporarily)
            nextDue = nextDue.plusMonths(1);

            // Step 5: Re-check if the next month has enough days
            // Example: If we're going from Jan 31 to Feb, we need to adjust to Feb 28/29
            int nextMonthLastDay = nextDue.lengthOfMonth();
            if (dayOfMonth > nextMonthLastDay) {
                // Use the last day of the next month
                nextDue = nextDue.withDayOfMonth(nextMonthLastDay);
            } else {
                // Use the original dayOfMonth
                nextDue = nextDue.withDayOfMonth(dayOfMonth);
            }
        }

        return nextDue;
    }

    // Getters and setters

    public long getId() {
        return id;
    }

    public User getUser() {
        return user;
    }

    public String getDescription() {
        return description;
    }

    public double getAmount() {
        return amount;
    }

    public String getType() {
        return type;
    }

    public String getCategory() {
        return category;
    }

    public Integer getDayOfMonth() {
        return dayOfMonth;
    }

    public LocalDate getNextDueDate() {
        return nextDueDate;
    }

    public LocalDateTime getCreatedDate() {
        return createdDate;
    }

    public boolean isRecurring() {
        return isRecurring;
    }

    public boolean isPaid() {
        return isPaid;
    }

    public LocalDate getDueDate() {
        return dueDate;
    }

    public void setId(long id) {
        this.id = id;
    }

    public void setUser(User user) {
        this.user = user;
    }

    public void setDescription(String description) {
        this.description = description;
    }

    public void setAmount(double amount) {
        this.amount = amount;
    }

    public void setType(String type) {
        this.type = type;
    }

    public void setCategory(String category) {
        this.category = category;
    }

    public void setDayOfMonth(Integer dayOfMonth) {
        this.dayOfMonth = dayOfMonth;
    }

    public void setNextDueDate(LocalDate nextDueDate) {
        this.nextDueDate = nextDueDate;
    }

    public void setCreatedDate(LocalDateTime createdDate) {
        this.createdDate = createdDate;
    }

    public void setRecurring(boolean isRecurring) {
        this.isRecurring = isRecurring;
    }

    public void setPaid(boolean isPaid) {
        this.isPaid = isPaid;
    }

    public void setDueDate(LocalDate dueDate) {
        this.dueDate = dueDate;
    }
}
